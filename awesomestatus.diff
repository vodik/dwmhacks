--- a/config.mk	2010-03-16 18:54:40.423476995 -0400
+++ b/config.mk	2010-03-16 18:54:05.173954860 -0400
@@ -16,7 +16,7 @@
 
 # includes and libs
 INCS = -I. -I/usr/include -I${X11INC}
-LIBS = -L/usr/lib -lc -L${X11LIB} -lX11 ${XINERAMALIBS}
+LIBS = -L/usr/lib -lc -L${X11LIB} -lX11 ${XINERAMALIBS} -lXpm
 
 # flags
 CPPFLAGS = -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
--- a/config.def.h	2010-03-16 03:23:09.932574938 -0400
+++ b/config.h	2010-03-16 18:38:03.319894411 -0400
@@ -33,6 +33,64 @@
 	{ "[M]",      monocle },
 };
 
+static const char *english_flag_xpm[] = {
+	"16 16 3 1",
+	"   c #FFFF00000000",
+	".  c #FFFFFFFFFFFF",
+	"X  c #00000000FFFF",
+	" .XXXX.  .XXXX. ",
+	". .XXX.  .XXX. .",
+	"X. .XX.  .XX. .X",
+	"XX. .X.  .X. .XX",
+	"XXX. ..  .. .XXX",
+	"XXXX. .  . .XXXX",
+	"......    ......",
+	"                ",
+	"                ",
+	"......    ......",
+	"XXXX. .  . .XXXX",
+	"XXX. ..  .. .XXX",
+	"XX. .X.  .X. .XX",
+	"X. .XX.  .XX. .X",
+	". .XXX.  .XXX. .",
+	" .XXXX.  .XXXX. "
+};
+
+#define test_width  16
+#define test_height 16
+static const unsigned char test_bits[] = {
+	0xff, 0xff, 0x01, 0x80, 0xfd, 0xbf, 0x05, 0xa0, 0xf5, 0xaf, 0x15, 0xa8,
+	0xd5, 0xab, 0x55, 0xaa, 0x55, 0xaa, 0xd5, 0xab, 0x15, 0xa8, 0xf5, 0xaf,
+	0x05, 0xa0, 0xfd, 0xbf, 0x01, 0x80, 0xff, 0xff
+};
+
+#define xlogo16_width  16
+#define xlogo16_height 16
+static const unsigned char xlogo16_bits[] = {
+	0x0f, 0x80, 0x1e, 0x80, 0x3c, 0x40, 0x78, 0x20, 0x78, 0x10, 0xf0, 0x08,
+	0xe0, 0x09, 0xc0, 0x05, 0xc0, 0x02, 0x40, 0x07, 0x20, 0x0f, 0x20, 0x1e,
+	0x10, 0x1e, 0x08, 0x3c, 0x04, 0x78, 0x02, 0xf0
+};
+
+static const Image images[] = {
+	{ .xpm = {
+		.type   = ImgXpm,
+		.data   = english_flag_xpm,
+	} },
+	{ .xbm = {
+		.type   = ImgXbm,
+		.bits   = xlogo16_bits,
+		.width  = xlogo16_width,
+		.height = xlogo16_height,
+	} },
+	{ .xbm = {
+		.type   = ImgXbm,
+		.bits   = test_bits,
+		.width  = test_width,
+		.height = test_height,
+	} },
+};
+
 /* key definitions */
 #define MODKEY Mod1Mask
 #define TAGKEYS(KEY,TAG) \
@@ -46,7 +104,7 @@
 
 /* commands */
 static const char *dmenucmd[] = { "dmenu_run", "-fn", font, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
-static const char *termcmd[]  = { "uxterm", NULL };
+static const char *termcmd[]  = { "urxvt", NULL };
 
 static Key keys[] = {
 	/* modifier                     key        function        argument */
--- a/dwm.c	2010-03-16 03:37:34.278322984 -0400
+++ b/dwm.c	2010-03-16 18:29:02.970078237 -0400
@@ -36,6 +36,7 @@
 #include <X11/Xlib.h>
 #include <X11/Xproto.h>
 #include <X11/Xutil.h>
+#include <X11/xpm.h>
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
@@ -93,6 +94,22 @@
 	Window win;
 };
 
+enum { ImgXbm, ImgXpm };
+
+typedef union {
+	int type;
+	struct {
+		int type;
+		unsigned int width;
+		unsigned int height;
+		const unsigned char *bits;
+	} xbm;
+	struct {
+		int type;
+		const char **data;
+	} xpm;
+} Image;
+
 typedef struct {
 	int x, y, w, h;
 	unsigned long norm[ColLast];
@@ -273,6 +290,8 @@
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
+Pixmap pixmaps[LENGTH(images)];
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -676,6 +695,149 @@
 	return m;
 }
 
+enum { DrawText, DrawPixbuf };
+
+typedef struct Step Step;
+struct Step {
+	int type;
+	int color;
+	int length;
+	union {
+		char text[256];
+		int pixbuf;
+	} data;
+	Step *next;
+};
+
+Step *
+newstep(Step *old) {
+	Step *stp = malloc(sizeof(Step));
+	stp->type = DrawText;
+	stp->length = 0;
+	stp->next = old;
+	return stp;
+}
+
+Step *
+parsetext(const char *text) {
+	const char *c = text;
+	char oper = 0;
+	int ctrl = 0, val = 0, color = 0;
+	Step *stp = newstep(NULL);
+
+	while(*c) {
+		if(ctrl) {
+			if(ctrl == 1) {
+				switch(*c) {
+					case '%':
+						ctrl = 0;
+						if (stp->length < 256)
+							stp->data.text[stp->length++] = '%';
+						break;
+					case '{':
+						ctrl = 2;
+						if(stp->length > 0) {
+							stp->color = color;
+							stp->data.text[stp->length] = '\0';
+							stp = newstep(stp);
+						}
+						break;
+				}
+			}
+			else if(ctrl == 2) {
+				if(*c == '}') {
+					switch(oper) {
+						case 'c':
+							color = val;
+							break;
+						case 'r':
+							color = 0;
+							break;
+						case 'i':
+							if(stp->length > 0) {
+								stp->color = color;
+								stp->data.text[stp->length] = '\0';
+								stp = newstep(stp);
+							}
+							stp->color = color;
+							stp->type = DrawPixbuf;
+							stp->data.pixbuf = val;
+							stp = newstep(stp);
+							break;
+					}
+					oper = val = ctrl = 0;
+				}
+				else {
+					switch(*c) {
+						case 'c':
+						case 'r':
+						case 'i':
+							oper = *c;
+							break;
+						default:
+							if(oper) {
+								val *= 10;
+								val += *c - '0';
+							}
+							break;
+					}
+				}
+			}
+		}
+		else if(*c == '%')
+			ctrl = 1;
+		else
+			if (stp->length < 256)
+				stp->data.text[stp->length++] = *c;
+		++c;
+	}
+	stp->color = color;
+	stp->data.text[stp->length] = '\0';
+	return stp;
+}
+
+void
+drawimage(int img, unsigned long col[ColLast], Bool invert) {
+	int x, y, h;
+	XRectangle r = { dc.x, dc.y, dc.w, dc.h };
+
+	XSetForeground(dpy, dc.gc, col[invert ? ColFG : ColBG]);
+	XFillRectangles(dpy, dc.drawable, dc.gc, &r, 1);
+
+	h = dc.font.ascent + dc.font.descent;
+	y = dc.y;// + (dc.h / 2) - (h / 2) + dc.font.ascent;
+	x = dc.x;// + (h / 2);
+
+	XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);
+	XCopyArea(dpy, pixmaps[img], dc.drawable, dc.gc, 0, 0, 16, 16, x, y);
+}
+
+void
+drawspecial(Monitor *m, const char *text) {
+	Step *step = parsetext(text);
+	Step *tmp;
+
+	dc.x = m->ww;
+	while(step) {
+		if(step->type == DrawText) {
+			printf("drew text\n");
+			dc.w = TEXTW(step->data.text);
+			dc.x -= dc.w;
+			drawtext(step->data.text, dc.norm, False);
+		}
+		else if(step->type == DrawPixbuf) {
+			printf("drew image\n");
+			dc.w = 16;
+			dc.x -= dc.w;
+			drawimage(step->data.pixbuf, dc.norm, False);
+		}
+		tmp = step;
+		step = step->next;
+		free(tmp);
+	}
+	printf("done\n");
+}
+
 void
 drawbar(Monitor *m) {
 	int x;
@@ -701,15 +863,8 @@
 	drawtext(m->ltsymbol, dc.norm, False);
 	dc.x += dc.w;
 	x = dc.x;
-	if(m == selmon) { /* status is only drawn on selected monitor */
-		dc.w = TEXTW(stext);
-		dc.x = m->ww - dc.w;
-		if(dc.x < x) {
-			dc.x = x;
-			dc.w = m->ww - x;
-		}
-		drawtext(stext, dc.norm, False);
-	}
+	if(m == selmon) /* status is only drawn on selected monitor */
+		drawspecial(m, stext);
 	else
 		dc.x = m->ww;
 	if((dc.w = dc.x - x) > bh) {
@@ -1475,6 +1630,7 @@
 void
 setup(void) {
 	XSetWindowAttributes wa;
+	int i;
 
 	/* clean up any zombies immediately */
 	sigchld(0);
@@ -1509,6 +1665,22 @@
 	XSetLineAttributes(dpy, dc.gc, 1, LineSolid, CapButt, JoinMiter);
 	if(!dc.font.set)
 		XSetFont(dpy, dc.gc, dc.font.xfont->fid);
+	/* init pixmaps */
+	for(i = 0; i < LENGTH(images); i++) {
+		printf("loading\n");
+		if(images[i].type == ImgXbm) {
+			printf("loaded xbm\n");
+			pixmaps[i] = XCreatePixmapFromBitmapData(dpy, root, (char *)images[i].xbm.bits,
+					images[i].xbm.width, images[i].xbm.height,
+					dc.norm[ColFG], dc.norm[ColBG], 1);
+			printf("width: %d, height %d\n", images[i].xbm.width, images[i].xbm.height);
+		}
+		else if(images[i].type == ImgXpm) {
+			printf("loaded xpm\n");
+			XpmCreatePixmapFromData(dpy, root, (char **)images[i].xpm.data, &pixmaps[i], NULL, NULL);
+		}
+	}
+	printf("loading done\n");
 	/* init bars */
 	updatebars();
 	updatestatus();
